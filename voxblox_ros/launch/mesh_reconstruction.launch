<launch>

  <!--
  USE INSTRUCTIONS
  
  1. Go to directory of the bagfile

  2. Launch this file setting the parameter 'path_folder:=$(pwd)':
    roslaunch voxblox_ros mesh_reconstruction.launch path_folder:=$(pwd)

  3. Once the mesh is done save the .ply using the voxblox service as follows:
    rosservice call /voxblox_node/generate_mesh
    rosservice call /mussol/voxblox_node/generate_mesh
  The mesh will be saved into the path_folder directory
  -->
   
  <arg name="namespace" default="mussol" /> 
  <arg name="robot_radius" default="0.55" />
  <arg name="resolution" default="0.15" />
  <arg name="max_range" default="15.0" />
  <arg name="icp" default="True" />
  <arg name="voxblox" default="True" />
  <arg name="vb_mode" default="simple" /> <!-- fast, merged or simple -->
  <arg name="pc_filter" default="False" />
  <arg name="rviz" default="True" />

 

  <!-- Rosbag play -->
  <arg name="path_folder" default="/home/tonitauler/Desktop/Bagflies" />
  <arg name="rosbag_rate" default="1.0" />
  <arg name="rosbag_start" default="8.0" />
  <arg name="rosbag_duration" default="200.0" />
   
  <arg name="mesh_name" default="mesh"/>


  <!-- Rosbag Node -->
  <node name="rosbag_play" pkg="voxblox_ros" type="rosbag_play.bash" args="$(arg path_folder) $(arg rosbag_rate) $(arg rosbag_start) $(arg rosbag_duration)" output="screen">
  </node>

  <group ns="$(arg namespace)">

    <!-- Point Cloud filtering -->
    <group if="$(arg pc_filter)">
      <node pkg="pointcloud_tools"
            type="pointcloud_filtering"
            name="pointcloud_filtering"
            output="screen"
            respawn="true">
                <param name="apply_x_limits" type="bool" value="true"/>
                <param name="apply_y_limits" type="bool" value="true"/>
                <param name="apply_z_limits" type="bool" value="true"/>
                <param name="apply_voxel_grid" type="bool" value="true"/>
                <param name="apply_outlier_removal" type="bool" value="true"/>
                <param name="x_filter_min" type="double" value="-10.0"/>
                <param name="x_filter_max" type="double" value="10.0"/>
                <param name="y_filter_min" type="double" value="-10.0"/>
                <param name="y_filter_max" type="double" value="10.0"/>
                <param name="z_filter_min" type="double" value="0.2"/>
                <param name="z_filter_max" type="double" value="10.0"/>
                <param name="voxel_size" type="double" value="0.15"/>
                <param name="mean_k" type="int" value="50"/>
                <param name="std_dev_thresh" type="double" value="1.0"/>
                <remap from="input" to="os_cloud/points" />
                <remap from="pointcloud_filtering/output" to="/pcl_filtered" />
      </node>
    </group>

    <group if="$(arg voxblox)">
      <node name="voxblox_node" pkg="voxblox_ros" type="esdf_server" output="screen" args="-alsologtostderr" clear_params="true">
        <remap from="pointcloud" to="/pcl_filtered" if="$(arg pc_filter)"/>
        <remap from="pointcloud" to="os_cloud/points" unless="$(arg pc_filter)"/>
        <param name="tsdf_voxel_size" value="$(arg resolution)" />
        <param name="tsdf_voxels_per_side" value="16" /> <!-- 16 -->
        <param name="color_mode" value="normals"/>
        <param name="use_tf_transforms" value="true" /> <!-- If false you have to publish the transform: world_frame -> sensor
                                                        to topic "transform" of type geometry_msgs::TransformStamped -->
        
        <!-- ICP -->
        <param name="enable_icp" value="$(arg icp)" />
        <param name="icp_iterations" value="10" />
        <param name="icp_mini_batch_size" value="20" />
        <param name="icp_subsample_keep_ratio" value="0.5" />
        <param name="icp_min_match_ratio" value="0.8" />
        <param name="icp_inital_translation_weighting" value="1000.0" />
        <param name="icp_inital_rotation_weighting" value="100.0" />

        <param name="use_const_weight" value="true" />


        <param name="verbose" value="false" />
        <param name="allow_clear" value="false" />
        <param name="max_ray_length_m" value="$(arg max_range)"/>
        <param name="min_ray_length_m" value="$(arg robot_radius)"/>
        <!-- <param name="update_mesh_every_n_sec" value="0.1"/> -->
        <param name="method" value="$(arg vb_mode)"/> <!-- fast, merged or simple -->
        <param name="mesh_filename" value="$(arg path_folder)/$(arg mesh_name)_$(arg resolution)_$(arg vb_mode).ply" />
        <!-- <param name="world_frame" value="odom" /> -->
        <param name="world_frame" value="mussol/nav" />
        <param name="sensor_frame" value="" /> <!-- "" means directly frame of the input pointcloud header-->

        <param name="allow_clear" value="True" />
        <param name="clearing_ray_weight_factor" value="0.01" />
        <param name="max_weight" value="200" />
        <param name="mesh_min_weight" value="1e-4" />
        <param name="max_consecutive_ray_collisions" value="2" />
        <param name="occupancy_min_distance_voxel_size_factor" value="1.0" />
        <param name="sparsity_compensation_factor" value="50.0" />
        <param name="use_sparsity_compensation_factor" value="True" />
        <param name="truncation_distance" value="0.6" />
        <param name="weight_ray_by_range" value="False" />
        <param name="use_weight_dropoff" value="True" />
        <param name="use_symmetric_weight_drop_off" value="False" />
        <param name="voxel_carving_enabled" value="True" />
        <param name="timestamp_tolerance_sec" value="0.001" />
        <param name="integration_order_mode" value="sorted" />  
        <param name="pointcloud_queue_size" value="1000" />

      </node>
    </group>
  </group>

  <!-- RVIZ -->   
  <group if="$(arg rviz)"> 
    <node name="rviz" pkg="rviz" type="rviz" args="-d /home/tonitauler/ROS/drone_ws/src/m100_simulation/rviz/rosbag_drone.rviz" output="log"/>
  </group>

</launch>
